# -*- python -*-
# ex: set filetype=python:

from buildbot.plugins import *
import copy
import os.path
import datetime
import random

import builders
import build
import common
import debs
import markdown
import reports
import rpms
import schedulers

c = BuildmasterConfig = {}

#The branches you want to configure builders for
branches = {
{% for branch in opencast %}
  '{{ branch }}': {
    'branch': '{{ opencast[branch]["branch"] }}',
    'pom': '{{ opencast[branch]["pom"] }}',
    'server': '{{ opencast[branch]["server"] | default(None) }}',
    'jdk': {{ opencast[branch]["jdk"] }}
  },
{% endfor %}
}
#
####### WORKERS

workerProps = {
{% for worker in groups['workers'] %}
  '{{ hostvars[worker]["name"] }}': {
{% if not worker in groups['master'] %}
    'port': '{{ (hostvars[worker]['id'] + 2375) }}',
{% else %}
    'port': '2375',
    'max_jobs': '{{ hostvars[worker]["ansible_processor_count"] }}',
{% endif %}
    'deb_repo_fragment': '{{ hostvars[worker]["deb_repo_fragment"] | default(deb_repo_fragment) }}',
    'rpm_repo_fragment': '{{ hostvars[worker]["rpm_repo_fragment"] | default(rpm_repo_fragment) }}',
    'repo_builder': '{{ hostvars[worker]["repo_builder"] | default(False) }}',
    'repo_path': [ '{{ hostvars[worker]["disk_base"] | default(disk_base) }}:{{ hostvars[worker]["disk_base"] | default(disk_base) }}' ]
  },
{% endfor %}
}

shared_volumes = [ '{{ buildbot_home }}/.ssh:/builder/.ssh', '{{ buildbot_home }}/m2:/builder/m2', '{{ buildbot_home }}/ansible:/builder/.ansible', '{{ buildbot_config_worker }}:{{ buildbot_config }}:ro',{% if write_through %} '{{ buildbot_home }}/builds:/builds'{% endif %} ]
#If the worker is a repo builder, create the volumes property with the repo paths,
# otherwise omit the repo paths from the volumes mounted to docker
for w in workerProps:
  if workerProps[w]['repo_builder']:
    workerProps[w]['volumes'] = shared_volumes + workerProps[w]['repo_path']
  else:
    workerProps[w]['volumes'] = shared_volumes


#At pipeline runtime, picks the docker image to use
@util.renderer
def selectDockerName(props):
  docker_images = {{ docker_worker_images }}

  #Pick one at random, set it as a build property
  if not props.hasProperty('image'):
    osname = random.choice(docker_images)
    props.setProperty('image', osname, "Build")
  else:
    osname = props.getProperty('image')

  #Build the actual name to use
  return "ocqa-" + osname + "-worker:{{ docker_worker_image_tag }}"


#Generates the workers based on the contents of workerProps
def generateWorkers():
  workers = []
  for w in workerProps.keys():
    myProps = workerProps[w]

    #Setting password=None here causes the latent worker to autogenerate a random password and transmit it via env variables!
    latentWorker = worker.DockerLatentWorker(w, password=None,
                docker_host='tcp://localhost:' + myProps['port'],
                image=selectDockerName,
                volumes=myProps['volumes'],
                properties=myProps,
                autopull=True,
                masterFQDN="localhost:9989",
                hostconfig={ "network_mode": "host", "auto_remove": True }, #Host mode needed to use the ssh-forwarded tunnel
                followStartupLogs=True,
#               So this sounds good in theory, but in practice the job dispatching doesn't quite catch that
#                a worker is spun up using a specific distro, and dispatches inappropriate jobs to the worker (c.f: rpm builds to a deb)
#                locks=[util.MasterLock(w['max_jobs']).access('exclusive')])
                locks=[util.MasterLock(w).access('exclusive')])
    workers.append(latentWorker)
  return workers


# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = generateWorkers()

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

{% if enable_polling %}
repo = changes.GitPoller(repourl="{{ source_repo_url }}",
                              branches=True,
                              pollinterval={{ poll_interval }},
                              buildPushesWithNoCommits=True)

pull_requests = changes.GitHubPullrequestPoller(
                              owner="{{ source_pr_owner }}",
                              repo="{{ source_pr_slug }}",
                              pollAtLaunch=True,
                              pollInterval={{ poll_interval }},
                              repository_type="git",
                              token="{{ github_token }}",
                              magic_link=True)

c['change_source'] = [ repo, pull_requests ]
{% else %}
#We're using a webhook, so other change sources are not needed
c['change_source'] = []
{% endif %}

####### BUILDERS & SCHEDULERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

c['builders'] = []

# Configure the Schedulers, which decide how to react to incoming changes.

c['schedulers'] = []

generalBuilderNames=[]
allNames=[]

for pretty_branch_name in branches:
    props = {
        'git_branch_name': branches[pretty_branch_name]['branch'],
        'pkg_major_version': branches[pretty_branch_name]['pom'],
        'pkg_minor_version': "x",
        'branch_pretty': pretty_branch_name,
        'signing_key': '{{ signing_key_id }}',
        'package_all': {{ package_all }},
        'has_repo_builder': {{ has_repo_builder }},
        'deploy_env': branches[pretty_branch_name]['server'],
        'jdk': branches[pretty_branch_name]['jdk']
    }
    c['builders'].extend(builders.getBuildersForBranch(props))
    c['schedulers'].extend(schedulers.getSchedulers(props))

    #These are used for the mail notifiers below
    generalBuilderNames.extend(
        [ pretty_branch_name + " " + build_type + " JDK " + str(jdk)
            for build_type in [ 'Build', 'Reports' ]
            for jdk in common.getJDKBuilds(props, pretty_branch_name)])
    allNames = list(generalBuilderNames)
    for build_type in (" Markdown", " Database Tests"):
      generalBuilderNames.append(pretty_branch_name + build_type)
      allNames.append(pretty_branch_name + build_type)
    for build_type in (" Debian Packaging", " Debian Repository", " el7 RPM Packaging", " el8 RPM Packaging", " RPM Repository"):
      allNames.append(pretty_branch_name + build_type)
    if 'server' in branches[pretty_branch_name]:
      allNames.append(" Ansible Deploy")


####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

irc = reporters.IRC("irc.freenode.net", "oc-buildbot",
                 channels=["#opencast"],
                 allowForce=False,
                 allowShutdown=False,
                 notify_events={
                   'exception': 1,
                   'successToFailure': 1,
                   'failureToSuccess': 1,
                 })

{% raw %}
template=u'''\
<h4>Build status: {{ summary }}</h4>
{% for step in build['steps'] %}
<p> {{ step['name'] }}: {{ step['results'] }}</p>
{% endfor %}
<p> Build link <a href="{{ build_url }}">here</a>
<p><b> -- The Buildbot</b></p>
'''
{% endraw %}

gmn = reporters.MailNotifier(fromaddr="buildbot@opencast.org",
                            sendToInterestedUsers=False,
                            mode=('failing', 'change', 'problem', 'warnings'),
                            extraRecipients=["{{ mail_to }}"],
                            builders=generalBuilderNames,
                            relayhost="localhost", smtpPort=25,
                            messageFormatter=reporters.MessageFormatter(
                                template=template, template_type='html',
                                wantProperties=True, wantSteps=True))

amn = reporters.MailNotifier(fromaddr="buildbot@opencast.org",
                            sendToInterestedUsers=False,
                            mode=('exception'),
                            extraRecipients=["{{ mail_to }}"],
                            builders=allNames,
                            relayhost="localhost", smtpPort=25,
                            messageFormatter=reporters.MessageFormatter(
                                template=template, template_type='html',
                                wantProperties=True, wantSteps=True))

gh = reporters.GitHubStatusPush(token="{{ github_token }}",
                                startDescription="Building...",
                                endDescription="Build done")

#IRC bot has no auth, and basic things cause massive stack traces :(
c['services'] = []
{% if send_mail_notifications %}
c['services'].append(gmn)
c['services'].append(amn)
{% endif %}
{% if send_gh_notifications %}
c['services'].append(gh)
{% endif %}

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "Opencast"
c['titleURL'] = "https://github.com/opencast/opencast"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://{{ inventory_hostname }}/{{buildbot_url}}"

from twisted.cred import strcred
# minimalistic config to activate new web UI
c['www'] = dict(port={{ buildbot_port }},
                default_page="grid",
                plugins=dict(
                    waterfall_view=True,
                    console_view=False,
                    grid_view=True,
                    badges={
                        "left_text": "Build",  # text on the left part of the image
                        "left_color": "#555",  # color of the left part of the image
                        "style": "plastic",  # style of the template availables are "flat", "flat-square", "plastic"
                        "template_name": "{style}.svg.j2",  # name of the template
                        "font_face": "DejaVu Sans",
                        "font_size": 11,
                        "color_scheme": {  # color to be used for right part of the image
                            "exception": "#007ec6",  # blue
                            "failure": "#e05d44",    # red
                            "retry": "#007ec6",      # blue
                            "running": "#007ec6",    # blue
                            "skipped": "a4a61d",     # yellowgreen
                            "passing": "#4c1",       # brightgreen
                            "unknown": "#9f9f9f",    # lightgrey
                            "warnings": "#dfb317"    # yellow
                        }
                    }
                ),
{% if enable_auth %}
                auth=util.GitHubAuth("{{ github_client_id }}", "{{ github_client_secret }}", apiVersion=4, getTeamsMembership=True),
                authz=util.Authz(
                        allowRules=[
                            util.AnyControlEndpointMatcher(role="Committers")
                        ],
                        roleMatchers=[
                            util.RolesFromGroups(groupPrefix='opencast/')
                        ]
                      ),
{% endif %}
                change_hook_auth=[strcred.makeChecker("file:changehook.passwd")],
                change_hook_dialects={
                  'github': {
                    'secret': "{{ github_hook_secret }}",
                    'strict': True,
                  }
                })

c['logCompressionMethod'] = 'gz'
#Don't set the settings below - they lead to log truncation
#c['logMaxSize'] = 1024*1024 # 1M
#c['logMaxTailSize'] = 32768
c['logEncoding'] = 'utf-8'
#Turn off usage data collection
c['buildbotNetUsageData'] = None
{% if debug_enabled %}
from buildbot import manhole
c['manhole'] = manhole.PasswordManhole("tcp:1234:interface=127.0.0.1","admin","passwd", ssh_hostkey_dir="{{ buildbot_config }}/ssh_host_keys/")
{% endif %}

#The path below is relative to the internal root of the master's docker image.  Do not change this.
c['secretsProviders'] = [secrets.SecretInAFile(dirname="{{ buildbot_config }}/secrets")]

#Clean up the database - note that this does *not* clean up the filesystem!
c['configurators'] = [util.JanitorConfigurator(
    logHorizon=datetime.timedelta(weeks=4),
    hour=0
)]

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : os.environ.get("BUILDBOT_DB_URL", "sqlite://").format(**os.environ),
}
